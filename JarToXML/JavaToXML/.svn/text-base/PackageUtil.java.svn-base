package DynamicTraceability.Toolkit.JavaToXML;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

import org.dom4j.Document;
import org.dom4j.Element;

import DynamicTraceability.Toolkit.Entity.JavaClass;
import DynamicTraceability.Toolkit.Entity.JavaCodeElement;
import DynamicTraceability.Toolkit.Entity.JavaPackage;
import DynamicTraceability.Toolkit.Tool.ConfigReader;
import DynamicTraceability.Toolkit.Tool.SimpleLoader;
import DynamicTraceability.Toolkit.Tool.XmlOperator;

/**
 * @since 2006-11-27
 * 
 * Modified History:
 * 
 */
public class PackageUtil {
	Integer id = 0;
	
	String jarName = "";// "pmreqwss.jar";

	String packageName = "";

	String saveXmlName = "";// "reqwss.xml";

	String jarFilePath = "";// "F:\\My
							// Projects\\DynamicTraceability\\JavaMetaClass\\";

	String targetJarPath = "";// jarFilePath + jarName;

	String saveXmlPath = "";

	public PackageUtil() {
		ConfigReader configReader = ConfigReader.getInstance();
		configReader.readConfig();
		saveXmlPath = configReader.outputXmlPath;
		packageName = configReader.packagaName;
		jarName = configReader.jarName;
		jarFilePath = configReader.jarFilePath;
		targetJarPath = jarFilePath + jarName;
	}

	/**
	 * @param args
	 * @throws IOException
	 */
	public static void main(String[] args) throws IOException,
			ClassNotFoundException {
		PackageUtil packageUtil = new PackageUtil();
		JavaPackage rootPack = packageUtil.classDetailToMap();
		packageUtil.mapToXML(rootPack);
	}
	
	private void setClass(JavaClass classNode, Element parentElement) {
		Element classElement = parentElement.addElement(JavaToXMLConstant.classNodeName);
		//为代码设置编号
		classElement.addAttribute(JavaToXMLConstant.id, id.toString());
		id = id.intValue() + 1;
		classElement.addAttribute(JavaToXMLConstant.classNodeAttrName, classNode.elementName);
		classElement.addAttribute(JavaToXMLConstant.classNodeAttrDlyName, classNode.displayName);
		
		//设置方法和属性
		setMethod(classNode.thisClass, classElement);
		setFiled(classNode.thisClass, classElement);
		
		//设置嵌套类
		Iterator itClass = classNode.subElementMap.values().iterator();
		while( itClass.hasNext() ) {
			JavaClass nestClass = (JavaClass)itClass.next();
			setClass(nestClass, classElement);
		}
	}
	
	private void setMethod(Class classNode, Element classElement) {
		// 解析方法
		try {
			Method[] meths = classNode.getDeclaredMethods();
			for (int i = 0; i < meths.length; i++) {
				String methName = meths[i].getName();
				String methDisplayName = "";

				boolean hasLine = methName.contains("_");
				// 如果全部是大写
				if (methName.equals(methName.toUpperCase()) && !hasLine) {
					methDisplayName = methName.toLowerCase();
				} else {
					if (hasLine) {
						// char[] methChars = methName.toCharArray();
						methDisplayName = splitStringByLine(methName);
					} else {
						// char[] methChars = methName.toCharArray();
						methDisplayName = splitStringByUpper(methName);
					}
				}

				Element methodElement = classElement
						.addElement(JavaToXMLConstant.mehtodNodeName);
				//为代码设置编号
				methodElement.addAttribute(JavaToXMLConstant.id,
						id.toString());
				id = id.intValue() + 1;
				
				methodElement.addAttribute(JavaToXMLConstant.mehtodNodeAttrName,
						methName);
				methodElement.addAttribute(JavaToXMLConstant.mehtodNodeAttrDlyName,
						methDisplayName);
			}
		} catch (Exception ex) {

		} catch (Error error) {

		}
	}

	private void setFiled(Class classNode, Element classElement) {
		// 解析字段
		try {
			Field[] fields = classNode.getDeclaredFields();
			for (int i = 0; i < fields.length; i++) {
				String fieldName = fields[i].getName();
				String fieldDisplayName = "";

				boolean hasLine = fieldName.contains("_");
				// 如果全部是大写 而且不包含"_"
				if (fieldName.equals(fieldName.toUpperCase()) && !hasLine) {
					fieldDisplayName = fieldName.toLowerCase();
				} else {
					if (hasLine) {
						fieldDisplayName = splitStringByLine(fieldName);
					} else {
						fieldDisplayName = splitStringByUpper(fieldName);
					}
				}

				Element fieldElement = classElement
						.addElement(JavaToXMLConstant.fieldNodeName);
				fieldElement.addAttribute(JavaToXMLConstant.id,
						id.toString());
				id = id.intValue() + 1;
				
				fieldElement.addAttribute(JavaToXMLConstant.fieldNodeAttrName,
						fieldName);
				fieldElement.addAttribute(JavaToXMLConstant.fieldNodeAttrDlyName,
						fieldDisplayName);
			}
		} catch (Exception ex) {

		} catch (Error error) {

		}
	}
	
	private void saveToXml(Map packLevelMap, Element packageElement) {
		Iterator nodeIt = packLevelMap.values().iterator();
		//先添加包，再添加类
		List javaClassList = new LinkedList();
		while(nodeIt.hasNext()) {
			JavaCodeElement element = (JavaCodeElement)nodeIt.next();
			if ( element instanceof JavaPackage) {
				// 添加根结点
				Element packElement = packageElement.addElement(JavaToXMLConstant.packNodeName);
				packElement.addAttribute(JavaToXMLConstant.id, id.toString());
				id= id.intValue() + 1;
				packElement.addAttribute(JavaToXMLConstant.packNodeAttrNs, element.elementName);
				saveToXml(element.subElementMap, packElement);
			}
			else if ( element instanceof JavaClass) {
				javaClassList.add(element);
//				JavaClass classNode = (JavaClass)element;		
//				setClass(classNode, packageElement);
			}
		}
		
		Iterator classIt = javaClassList.iterator();
		while(classIt.hasNext()) {
			JavaClass classNode = (JavaClass)classIt.next();
			setClass(classNode, packageElement);
		}
	}
	
	public void mapToXML(JavaPackage rootPack) throws IOException, ClassNotFoundException {
		XmlOperator jarXml = new XmlOperator();
		Document doc = jarXml.createDoc();

		// 添加根结点
		Element rootElement = doc.addElement(JavaToXMLConstant.packNodeName);
		rootElement.addAttribute(JavaToXMLConstant.id, id.toString());
		id= id.intValue() + 1;
		rootElement.addAttribute(JavaToXMLConstant.packNodeAttrNs, packageName);
		
//		Map packLevelMap = (Map)codeMap.get(packageName);
		
		saveToXml(rootPack.subElementMap, rootElement);

		rootElement.addAttribute(JavaToXMLConstant.packNodeAttrClsNo, "0");
		jarXml.saveDoc(saveXmlPath);
	}

	public JavaPackage classDetailToMap() throws IOException, ClassNotFoundException {

		JavaPackage rootPack = new JavaPackage();
		rootPack.elementName = packageName;

		Map codeMap = new HashMap();

		codeMap.put(packageName, rootPack);

		List<String> cls = getClassInPackage(packageName);
		int p = 0;
		for (String s : cls) {
			p++;
			try {
				SimpleLoader loader = new SimpleLoader();
				Class classanyway = loader.findClass(s, targetJarPath);
				// Class classanyway = Class.forName(s);

				String className = classanyway.getName();
				String packName = className.substring(0, className
						.lastIndexOf("."));
//				System.out.println(" packName = " + packName);
				String classSimpleName = className.substring(className
						.lastIndexOf(".") + 1);
//				System.out.println(" classSimpleName = " + classSimpleName);
				String displayName = splitStringByUpper(classSimpleName);

				JavaClass classNode = new JavaClass();
				classNode.elementName = className;
				classNode.displayName = displayName;
				classNode.thisClass = classanyway;
				// 如果已经存在名称空间
				if (codeMap.containsKey(packName)) {
					JavaPackage packNode = (JavaPackage) codeMap.get(packName);

					// 如果为嵌套类
					if (classSimpleName.contains("$")) {
						String nestingName = classSimpleName
								.substring(classSimpleName.lastIndexOf("$") + 1);
						classNode.displayName = splitStringByUpper(nestingName);

						String nestFatherName = classSimpleName.substring(0,
								classSimpleName.lastIndexOf("$"));
						String nestFatherFullName = packName + "."
								+ nestFatherName;
						// 检查嵌套父类是否已经存在
						if (packNode.subElementMap
								.containsKey(nestFatherFullName)) {
							JavaClass classNestFatherNode = (JavaClass) packNode.subElementMap
									.get(nestFatherFullName);
							classNestFatherNode.subElementMap.put(className,
									classNode);
						} else {
							// the nested father class
							JavaClass classNestFatherNode = new JavaClass();
							classNestFatherNode.elementName = nestFatherFullName;
							classNestFatherNode.displayName = splitStringByUpper(nestFatherName);
							classNestFatherNode.subElementMap.put(className,
									classNode);
							packNode.subElementMap.put(nestFatherFullName,
									classNestFatherNode);
						}
					} else {
						// 检查该类是否已经存在
						if (packNode.subElementMap.containsKey(className)) {
							classNode = (JavaClass) packNode.subElementMap
									.get(className);
							classNode.thisClass = classanyway;
						} else {
							packNode.subElementMap.put(classNode.elementName,
									classNode);
						}
					}
				} else {
					JavaPackage packNode = new JavaPackage();
					packNode.elementName = packName;
//					String leafNs = packName.substring(packName.lastIndexOf(".") + 1);
//					String[] splite

					// 如果为嵌套类,只考虑一层嵌套的情况
					if (classSimpleName.contains("$")) {
						String nestingName = classSimpleName
								.substring(classSimpleName.lastIndexOf("$") + 1);
						classNode.displayName = splitStringByUpper(nestingName);

						String nestFatherName = classSimpleName.substring(0,
								classSimpleName.lastIndexOf("$"));
						// the nested father class
						JavaClass classNestFatherNode = new JavaClass();
						classNestFatherNode.elementName = packName + "."
								+ nestFatherName;
						classNestFatherNode.displayName = splitStringByUpper(nestFatherName);

						classNestFatherNode.subElementMap.put(className,
								classNode);
						packNode.subElementMap.put(
								classNestFatherNode.elementName,
								classNestFatherNode);
					} else {
						packNode.subElementMap.put(className, classNode);
					}

					codeMap.put(packName, packNode);
				}

			} catch (Exception ex) {
			}
		}
		
		setPackageMap(codeMap);
		return rootPack;
	}
	
	/**
	 * 设置包的子包
	 *
	 */
	private void setPackageMap(Map codeMap) {
		Iterator it = codeMap.values().iterator();
		while(it.hasNext()) {
			JavaPackage curPack = (JavaPackage)it.next();
			String packName = curPack.elementName;
			//如果不是根包，则遍历
			if ( !packName.equalsIgnoreCase(packageName))  {
				String parentName = packName.substring(0, packName.lastIndexOf("."));
				JavaPackage parentPackage = (JavaPackage)codeMap.get(parentName);
				parentPackage.subElementMap.put(packName, curPack);
			}
		}
	}

	/**
	 * 
	 * @param methName
	 * @return
	 */
	private String splitStringByLine(String methName) {
		String methDisplayName = "";
		String[] wordList = methName.split("_");
		for (int i = 0; i < wordList.length; i++) {
			methDisplayName += wordList[i].toLowerCase() + " ";
		}
		methDisplayName = methDisplayName.substring(0,
				methDisplayName.length() - 1);
		return methDisplayName;
	}

	/**
	 * 
	 * @param methName
	 * @return
	 */
	private String splitStringByUpper(String methName) {
		String methDisplayName = "";
		char[] methChars = methName.toCharArray();
		int head = 0;
		List methWordList = new LinkedList();
		for (int j = 0; j < methChars.length; j++) {
			boolean isUpper = Character.isUpperCase(methChars[j]);
			if (isUpper && j != 0) {
				String word = methName.substring(head, j);
				head = j;

				methWordList.add(word);
				methDisplayName += (word.toLowerCase() + " ");
			}

			if (j == methChars.length - 1) {
				String word = methName.substring(head, j + 1);
				methWordList.add(word);
				methDisplayName += (word.toLowerCase());
			}
		}

		return methDisplayName;
	}

	public List<String> getClassInPackage(String pkgName) {
		List<String> ret = new ArrayList<String>();
		String rPath = pkgName.replace('.', '/') + "/";
		try {
			for (File classPath : CLASS_PATH_ARRAY) {
				if (!classPath.exists())
					continue;
				if (classPath.isDirectory()) {
					File dir = new File(classPath, rPath);
					if (!dir.exists())
						continue;
					for (File file : dir.listFiles()) {
						if (file.isFile()) {
							String clsName = file.getName();
							clsName = pkgName
									+ "."
									+ clsName
											.substring(0, clsName.length() - 6);
							ret.add(clsName);
						}
					}
				} else {
					FileInputStream fis = new FileInputStream(classPath);
					JarInputStream jis = new JarInputStream(fis, false);
					JarEntry e = null;
					while ((e = jis.getNextJarEntry()) != null) {
						String eName = e.getName();
						if (eName.startsWith(rPath) && !eName.endsWith("/")) {
							ret.add(eName.replace('/', '.').substring(0,
									eName.length() - 6));
							// System.out.println("eName = " + eName);
						}
						jis.closeEntry();
					}
					jis.close();
				}
			}
		} catch (Exception e) {
			throw new RuntimeException(e);
		}

		return ret;
	}

	private String[] CLASS_PATH_PROP = { "java.class.path", "java.ext.dirs",
			"sun.boot.class.path" };

	private List<File> CLASS_PATH_ARRAY = getClassPath();

	private List<File> getClassPath() {
		List<File> ret = new ArrayList<File>();
		String delim = ":";
		if (System.getProperty("os.name").indexOf("Windows") != -1)
			delim = ";";
		for (String pro : CLASS_PATH_PROP) {
			String[] pathes = System.getProperty(pro).split(delim);
			for (String path : pathes)
				ret.add(new File(path));
		}

		// ret.add(new File(yourjarfilepath));

		return ret;
	}
}
